# 2021 Day 1

```elixir
Mix.install([
  {:kino, "~> 0.6.1"},
  {:kino_vega_lite, "~> 0.1.1"}
])

alias VegaLite, as: Vl
```

## Input

```elixir
raw_input = Kino.Input.textarea("Problem Input")
```

```elixir
defmodule AdventOfCode.InputFetcher do
  use Kino.JS
  use Kino.JS.Live
  use Kino.SmartCell, name: "Advent of Code Input Fetcher"

  def new() do
    Kino.JS.Live.new(__MODULE__, %{})
  end

  @impl true
  def init(attrs, ctx) do
    ctx = assign(ctx, year: attrs["year"] || "", day: attrs["day"])
    {:ok, ctx}
  end

  @impl true
  def handle_connect(ctx) do
    {:ok, nil, ctx}
  end

  @impl true
  def handle_event("fetch_input", data, ctx) do
    file_path = get_file_path(data["year"], data["day"])

    with {:ok, :doesnt_exist} <- file_doesnt_exist(file_path),
         {:ok, {_, _headers, body}} <- download_input(data["session"], data["year"], data["day"]),
         :ok <- File.write(file_path, body) do
      broadcast_event(ctx, "input_fetch_success", nil)
    else
      {:error, :exists} ->
        broadcast_event(ctx, "input_fetch_success", nil)

      error ->
        broadcast_event(ctx, "error", error)
    end

    {:noreply, assign(ctx, year: data["year"], day: data["day"])}
  end

  @impl true
  def handle_event("save_example", data, ctx) do
    file_path = get_file_path(data["year"], data["day"], "example_input")

    data_with_trailing_newline =
      case String.at(data["example"], -1) do
        '\n' -> data["example"]
        _ -> data["example"] <> "\n"
      end

    case File.write(file_path, data_with_trailing_newline) do
      :ok ->
        :ok

      error ->
        broadcast_event(ctx, "error", error)
    end

    {:noreply, assign(ctx, year: data["year"], day: data["day"])}
  end

  @impl true
  def to_attrs(ctx) do
    IO.inspect(ctx)
    %{"year" => ctx.assigns["year"], "day" => ctx.assigns["day"]}
  end

  @impl true
  def to_source(attrs) do
    quote do
      current_dir = Path.dirname(__ENV__.file)
      input = File.read!(Path.join([current_dir, unquote("aoc_#{"haha"}_1_input.txt")]))
      example_input = File.read!(Path.join([current_dir, "aoc_2021_1_example_input.txt"]))
      unquote(attrs)
      :ok
    end
    |> Kino.SmartCell.quoted_to_string()
  end

  defp get_file_path(year, day, extra \\ "input") do
    dir = Path.dirname(__ENV__.file)
    Path.join([dir, "aoc_#{year}_#{day}_#{extra}.txt"])
  end

  defp file_doesnt_exist(path) do
    case File.exists?(path) do
      true -> {:error, :exists}
      false -> {:ok, :doesnt_exist}
    end
  end

  defp download_input(session, year, day) do
    :inets.start()
    :ssl.start()

    :httpc.request(
      :get,
      {"https://adventofcode.com/#{year}/day/#{day}/input",
       [
         {:binary.bin_to_list("Cookie"), "session=#{session}"}
       ]},
      [],
      []
    )
  end

  asset "main.js" do
    """
    export function init(ctx, data) {
      ctx.importCSS("main.css");

      ctx.root.innerHTML = `
        <div id="error"></div>

        <div id="input">
          <div class="field">
            <label for="aoc_session">Session token</label>
            <input type="text" id="aoc_session" />
            <a href="javascript:undefined;" id="save_session">Save to localstorage</a>
          </div>

          <div class="field">
            <label for="aoc_year">Year</label>
            <input type="number" id="aoc_year" min="2015" max="2099" step="1" />
          </div>

          <div class="field">
            <label for="aoc_day">Day</label>
            <input type="number" id="aoc_day" min="1" max="25" />
          </div>

          <button id="aoc_fetch">Fetch and Save Input</button>
        </div>

        <div id="example" class="hidden">
          <div class="field">
            <label for="aoc_example">Paste Example Input Here</label>
            <textarea id="aoc_example" rows="10"></textarea>
          </div>

          <button id="aoc_save_example">Save Example</button>
        </div>

        <div id="convert_screen" class="hidden">
          <p>Input and Example Input saved. Please convert this SmartCell to source.</p>
        </div>
      `;

      // Allow easy reference of form elements
      const input_session = ctx.root.querySelector("#aoc_session");
      const input_year = ctx.root.querySelector("#aoc_year");
      const input_day = ctx.root.querySelector("#aoc_day");
      const button_fetch = ctx.root.querySelector("#aoc_fetch");
      const button_save_example = ctx.root.querySelector("#aoc_save_example");
      const div_error = ctx.root.querySelector("#error");
      const div_input = ctx.root.querySelector("#input");
      const div_example = ctx.root.querySelector("#example");
      const div_convert_screen = ctx.root.querySelector("#convert_screen");

      // Handle saving the session token to localstorage
      document.getElementById("save_session").addEventListener("click", function() {
        if (input_session.value != "") {
          localStorage.setItem("advent_of_code_session_token", input_session.value);
        }
      });

      // Load the session token from localstorage if it exists
      const token = localStorage.getItem("advent_of_code_session_token");
      if (token) {
        input_session.value = token;
      }

      // If it is December, set the default day to the current 
      // year and day, otherwise set it to last year and the first
      const currentYear = new Date().getFullYear();
      input_year.max = currentYear;
      if (new Date().getMonth() === 11) {
        input_day.value = new Date().getDate()
        const currentYear = new Date().getFullYear();
        input_year.value = currentYear;
      } else {
        input_day.value = 1;
        input_year.value = currentYear - 1;
      }

      // Trigger the input fetch
      button_fetch.addEventListener("click", function() {
        ctx.pushEvent("fetch_input", {
          session: input_session.value,
          year: input_year.value,
          day: input_day.value
        })
      });

      // Display errors
      ctx.handleEvent("error", function(error) {
        div_error.innerHTML = "Download Error. See JS Console for details.";
        console.log(error);
      });

      // Input fetch success
      ctx.handleEvent("input_fetch_success", function(_) {
        // Swap to example saving input
        div_input.classList.toggle("hidden");
        div_example.classList.toggle("hidden");
      });

      // Handle saving example
      button_save_example.addEventListener("click", function() {
        ctx.pushEvent("save_example", {
          example: document.getElementById("aoc_example").value,
          year: input_year.value,
          day: input_day.value
        });

        div_example.classList.toggle("hidden");
        div_convert_screen.classList.toggle("hidden");
      });
    }
    """
  end

  asset "main.css" do
    """
    .field, .field > label {
      display: block;
    }

    .field > a {
      font-size: 0.8em;
    }

    input, button {
      margin-bottom: 1em;
    }

    textarea {
      width: 80%
    }

    #error {
      background: #ff9194;
      padding: 0.5em;
      margin-bottom: 1em;
      border-radius: 3px;
    }

    #error:empty {
      display: none;
    }

    .hidden {
      display: none;
    }
    """
  end
end

Kino.SmartCell.register(AdventOfCode.InputFetcher)
```

<!-- livebook:{"attrs":{},"kind":"Elixir.AdventOfCode.InputFetcher","livebook_object":"smart_cell"} -->

```elixir
current_dir = Path.dirname(__ENV__.file)
input = File.read!(Path.join([current_dir, "aoc_haha_1_input.txt"]))
example_input = File.read!(Path.join([current_dir, "aoc_2021_1_example_input.txt"]))
%{"day" => nil, "year" => nil}
:ok
```

```elixir
current_dir = Path.dirname(__ENV__.file)
input = File.read!(Path.join([current_dir, "aoc_2021_1_input.txt"]))
example_input = File.read!(Path.join([current_dir, "aoc_2021_1_example_input.txt"]))
:ok
```

## Parse

```elixir
input =
  Kino.Input.read(raw_input)
  |> String.split("\n")
  |> Enum.map(&String.to_integer/1)
```

Simple graph of the depth over time

```elixir
{min, max} = Enum.min_max(input)

# Initialize the specification, optionally with some top-level properties
Vl.new(width: 400)
# Specify data source for the graphic using one of the data_from_* functions
|> Vl.data_from_values(depth: input, time: 0..length(input))
# Pick a visual mark
|> Vl.mark(:line)
# Map data fields to visual properties of the mark, in this case point positions
|> Vl.encode_field(:y, "depth", type: :quantitative, scale: [domain: [min, max], reverse: true])
|> Vl.encode_field(:x, "time", type: :quantitative)
```

## Part 1

Count the number of times the depth increased

```elixir
defmodule Part1 do
  def count_increases(depths) do
    depths
    # Group into overlapping chunks of two
    |> Enum.chunk_every(2, 1, :discard)
    # Keep only the ones that are increases
    |> Enum.filter(fn [first, second] ->
      first < second
    end)
    # Count the remaining pairs
    |> Enum.count()
  end
end

Part1.count_increases(input)
```

## Part 2

Count the the increases in a sliding three wide window of depths

```elixir
input
|> Enum.chunk_every(3, 1, :discard)
|> Enum.map(&Enum.sum/1)
|> Part1.count_increases()
```
