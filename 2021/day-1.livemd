# 2021 Day 1

```elixir
Mix.install([
  {:kino, "~> 0.6.1"},
  {:kino_vega_lite, "~> 0.1.1"}
])

alias VegaLite, as: Vl
```

## Input

```elixir
raw_input = Kino.Input.textarea("Problem Input")
```

```elixir
defmodule AdventOfCode.InputFetcher do
  use Kino.JS
  use Kino.JS.Live
  # use Kino.SmartCell, name: "Advent of Code Input Fetcher"

  def new() do
    Kino.JS.Live.new(__MODULE__, %{})
  end

  @impl true
  def init(_state, ctx) do
    {:ok, ctx}
  end

  @impl true
  def handle_connect(ctx) do
    {:ok, nil, ctx}
  end

  asset "main.js" do
    """
    export function init(ctx, data) {
      ctx.importCSS("main.css");

      ctx.root.innerHTML = `
        <div class="field">
          <label for="aoc_session">Session token</label>
          <input type="text" id="aoc_session" />
          <a href="javascript:undefined;" id="save_session">Save to localstorage</a> |
          <a href="javascript:undefined;" id="load_session">Load from localstorage</a>
        </div>

        <div class="field">
          <label for="aoc_day">Day</label>
          <input type="number" id="aoc_day" min="1" max="25" />
        </div>

        <button id="aoc_fetch">Fetch Input</button>
      `;

      // Allow easy reference of form elements
      const input_session = ctx.root.querySelector("#aoc_session");

      // Handle saving the session token to localstorage
      document.getElementById("save_session").addEventListener("click", function() {
        if (input_session.value != "") {
          localStorage.setItem("advent_of_code_session_token", input_session.value);
        }
      });

      // Handle loading the session token from localstorage
      document.getElementById("load_session").addEventListener("click", function() {
        const token = localStorage.getItem("advent_of_code_session_token");
        if (token) {
          input_session.value = token;
        }
      });
    }
    """
  end

  asset "main.css" do
    """
    .field, .field > label {
      display: block;
    }

    .field > a {
      font-size: 0.8em;
    }

    input {
      margin-bottom: 1em;
    }
    """
  end
end

# Kino.SmartCell.register(AdventOfCode.InputFetcher)
```

```elixir
AdventOfCode.InputFetcher.new()
```

## Parse

```elixir
input =
  Kino.Input.read(raw_input)
  |> String.split("\n")
  |> Enum.map(&String.to_integer/1)
```

Simple graph of the depth over time

```elixir
{min, max} = Enum.min_max(input)

# Initialize the specification, optionally with some top-level properties
Vl.new(width: 400)
# Specify data source for the graphic using one of the data_from_* functions
|> Vl.data_from_values(depth: input, time: 0..length(input))
# Pick a visual mark
|> Vl.mark(:line)
# Map data fields to visual properties of the mark, in this case point positions
|> Vl.encode_field(:y, "depth", type: :quantitative, scale: [domain: [min, max], reverse: true])
|> Vl.encode_field(:x, "time", type: :quantitative)
```

## Part 1

Count the number of times the depth increased

```elixir
defmodule Part1 do
  def count_increases(depths) do
    depths
    # Group into overlapping chunks of two
    |> Enum.chunk_every(2, 1, :discard)
    # Keep only the ones that are increases
    |> Enum.filter(fn [first, second] ->
      first < second
    end)
    # Count the remaining pairs
    |> Enum.count()
  end
end

Part1.count_increases(input)
```

## Part 2

Count the the increases in a sliding three wide window of depths

```elixir
input
|> Enum.chunk_every(3, 1, :discard)
|> Enum.map(&Enum.sum/1)
|> Part1.count_increases()
```
